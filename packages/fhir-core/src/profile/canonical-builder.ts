/**
 * fhir-profile — Canonical Profile Builder
 *
 * Converts a StructureDefinition (with populated snapshot) into the
 * internal {@link CanonicalProfile} semantic model defined in Phase 1.
 *
 * The CanonicalProfile is MedXAI's own abstraction optimized for
 * downstream consumption (validation, runtime, application layer):
 * - Pre-resolved inheritance (flattened snapshot)
 * - Semantic types (`max: 'unbounded'` instead of `"*"`)
 * - Non-optional flags (mustSupport/isModifier/isSummary always boolean)
 * - O(1) element lookup via `Map<string, CanonicalElement>`
 *
 * Exported functions:
 * - {@link buildCanonicalProfile} — convert full SD → CanonicalProfile
 * - {@link buildCanonicalElement} — convert single ElementDefinition → CanonicalElement
 * - {@link buildTypeConstraints} — convert ElementDefinitionType[] → TypeConstraint[]
 * - {@link buildBindingConstraint} — convert ElementDefinitionBinding → BindingConstraint
 * - {@link buildInvariants} — convert ElementDefinitionConstraint[] → Invariant[]
 * - {@link buildSlicingDefinition} — convert ElementDefinitionSlicing → SlicingDefinition
 *
 * @module fhir-profile
 */

import type {
  CanonicalProfile,
  CanonicalElement,
  TypeConstraint,
  BindingConstraint,
  Invariant,
  SlicingDefinition,
  SlicingDiscriminatorDef,
} from '../model/index.js';
import type {
  ElementDefinition,
  ElementDefinitionType,
  ElementDefinitionBinding,
  ElementDefinitionConstraint,
  ElementDefinitionSlicing,
  StructureDefinition,
} from '../model/index.js';

// =============================================================================
// Section 1: buildCanonicalProfile
// =============================================================================

/**
 * Convert a StructureDefinition (with snapshot) to a CanonicalProfile.
 *
 * Precondition: `sd.snapshot` must exist (generated by SnapshotGenerator).
 * If snapshot is missing, throws an error.
 *
 * @param sd - The StructureDefinition with populated snapshot.
 * @returns The internal CanonicalProfile representation.
 * @throws Error if sd.snapshot is missing.
 */
export function buildCanonicalProfile(sd: StructureDefinition): CanonicalProfile {
  if (!sd.snapshot?.element?.length) {
    throw new Error(
      `Cannot build CanonicalProfile: StructureDefinition '${sd.url ?? 'unknown'}' has no snapshot`,
    );
  }

  const elements = new Map<string, CanonicalElement>();

  for (const el of sd.snapshot.element) {
    const canonical = buildCanonicalElement(el);
    elements.set(canonical.path, canonical);
  }

  return {
    url: sd.url as string,
    version: sd.version ? (sd.version as string) : undefined,
    name: sd.name as string,
    kind: sd.kind,
    type: sd.type as string,
    baseProfile: sd.baseDefinition ? (sd.baseDefinition as string) : undefined,
    abstract: sd.abstract === true,
    derivation: sd.derivation,
    elements,
  };
}

// =============================================================================
// Section 2: buildCanonicalElement
// =============================================================================

/**
 * Convert a single ElementDefinition to a CanonicalElement.
 *
 * Applies the following normalizations:
 * - `max: "*"` → `max: 'unbounded'`; numeric strings → numbers
 * - `mustSupport/isModifier/isSummary: undefined` → `false`
 * - `constraint: undefined` → `[]`
 * - `type: undefined` → `[]`
 *
 * @param ed - The ElementDefinition from a snapshot.
 * @returns The normalized CanonicalElement.
 */
export function buildCanonicalElement(ed: ElementDefinition): CanonicalElement {
  const path = (ed.path as string) ?? '';
  const id = (ed.id as string) ?? path;

  // Convert max: "*" → 'unbounded', numeric string → number
  const max = convertMax(ed.max as string | undefined);

  // Convert min: default to 0
  const min = typeof ed.min === 'number' ? ed.min : 0;

  return {
    path,
    id,
    min,
    max,
    types: buildTypeConstraints(ed.type),
    binding: buildBindingConstraint(ed.binding),
    constraints: buildInvariants(ed.constraint),
    slicing: buildSlicingDefinition(ed.slicing),
    mustSupport: ed.mustSupport === true,
    isModifier: ed.isModifier === true,
    isSummary: ed.isSummary === true,
  };
}

// =============================================================================
// Section 3: buildTypeConstraints
// =============================================================================

/**
 * Convert ElementDefinitionType[] to TypeConstraint[].
 *
 * Returns an empty array if types is undefined or empty.
 *
 * @param types - The FHIR type array from an ElementDefinition.
 * @returns Normalized TypeConstraint array.
 */
export function buildTypeConstraints(
  types: readonly ElementDefinitionType[] | undefined,
): TypeConstraint[] {
  if (!types || types.length === 0) {
    return [];
  }

  return types.map((t) => {
    const constraint: TypeConstraint = {
      code: t.code as string,
    };

    if (t.profile && (t.profile as unknown[]).length > 0) {
      constraint.profiles = (t.profile as unknown[]).map((p) => p as string);
    }

    if (t.targetProfile && (t.targetProfile as unknown[]).length > 0) {
      constraint.targetProfiles = (t.targetProfile as unknown[]).map((p) => p as string);
    }

    return constraint;
  });
}

// =============================================================================
// Section 4: buildBindingConstraint
// =============================================================================

/**
 * Convert ElementDefinitionBinding to BindingConstraint.
 *
 * Returns undefined if binding is undefined or has no strength.
 *
 * @param binding - The FHIR binding from an ElementDefinition.
 * @returns Normalized BindingConstraint or undefined.
 */
export function buildBindingConstraint(
  binding: ElementDefinitionBinding | undefined,
): BindingConstraint | undefined {
  if (!binding || !binding.strength) {
    return undefined;
  }

  const result: BindingConstraint = {
    strength: binding.strength,
  };

  if (binding.valueSet) {
    result.valueSetUrl = binding.valueSet as string;
  }

  if (binding.description) {
    result.description = binding.description as string;
  }

  return result;
}

// =============================================================================
// Section 5: buildInvariants
// =============================================================================

/**
 * Convert ElementDefinitionConstraint[] to Invariant[].
 *
 * Returns an empty array if constraints is undefined or empty.
 *
 * @param constraints - The FHIR constraint array from an ElementDefinition.
 * @returns Normalized Invariant array.
 */
export function buildInvariants(
  constraints: readonly ElementDefinitionConstraint[] | undefined,
): Invariant[] {
  if (!constraints || constraints.length === 0) {
    return [];
  }

  return constraints.map((c) => {
    const invariant: Invariant = {
      key: c.key as string,
      severity: c.severity,
      human: c.human as string,
    };

    if (c.expression) {
      invariant.expression = c.expression as string;
    }

    if (c.source) {
      invariant.source = c.source as string;
    }

    return invariant;
  });
}

// =============================================================================
// Section 6: buildSlicingDefinition
// =============================================================================

/**
 * Convert ElementDefinitionSlicing to SlicingDefinition.
 *
 * Returns undefined if slicing is undefined.
 * Normalizes `ordered` to boolean (default false).
 *
 * @param slicing - The FHIR slicing from an ElementDefinition.
 * @returns Normalized SlicingDefinition or undefined.
 */
export function buildSlicingDefinition(
  slicing: ElementDefinitionSlicing | undefined,
): SlicingDefinition | undefined {
  if (!slicing) {
    return undefined;
  }

  const discriminators: SlicingDiscriminatorDef[] = (slicing.discriminator ?? []).map((d) => ({
    type: d.type,
    path: d.path as string,
  }));

  const result: SlicingDefinition = {
    discriminators,
    rules: slicing.rules,
    ordered: slicing.ordered === true,
  };

  if (slicing.description) {
    result.description = slicing.description as string;
  }

  return result;
}

// =============================================================================
// Section 7: Internal Helpers
// =============================================================================

/**
 * Convert FHIR max string to `number | 'unbounded'`.
 *
 * - `"*"` → `'unbounded'`
 * - `"0"`, `"1"`, `"5"` → `0`, `1`, `5`
 * - `undefined` → `1` (FHIR default)
 */
function convertMax(max: string | undefined): number | 'unbounded' {
  if (max === undefined || max === null) {
    return 1; // FHIR default
  }
  if (max === '*') {
    return 'unbounded';
  }
  const num = parseInt(max, 10);
  return isNaN(num) ? 1 : num;
}
